<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comparative Biospheromics Dashboard</title>
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&family=Exo+2:wght@700&family=VT323&family=Comfortaa:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js" charset="utf-8" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jstat/1.9.6/jstat.min.js"></script>
    <style>
        @font-face {
            font-family: 'Nasalization';
            src: url('https://raw.githubusercontent.com/aime2solve/SPRUCE/main/Nasalization.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
        }

        /* Base styles */
        body, html {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            background-color: #000000;
            font-family: 'Lato', sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        h1 {
            color: #00FFFF;
            text-align: center;
            padding: 2vh;
            font-family: 'Nasalization', sans-serif;
            font-size: calc(16px + 1.5vw);
            margin: 0;
            text-shadow: 2px 2px 4px #00CC66, -2px -2px 4px #00CC66, 0 0 10px #00FFFF;
            animation: glowBreathe 8s cubic-bezier(0.45, 0, 0.55, 1) infinite;
            flex-shrink: 0;
            z-index: 11;
            line-height: 1.5;
            text-transform: uppercase;
        }

        @keyframes glowBreathe {
            0%, 100% { text-shadow: 2px 2px 4px #00CC66, -2px -2px 4px #00CC66, 0 0 10px #00FFFF; }
            25%, 75% { text-shadow: 2px 2px 5px #00CC66, -2px -2px 5px #00CC66, 0 0 12px #00FFFF; }
            50% { text-shadow: 2px 2px 4.5px #00CC66, -2px -2px 4.5px #00CC66, 0 0 11px #00FFFF; }
        }

        .container {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
            height: calc(100vh - 4vh);
            position: relative;
        }

        /* Sidebar styles */
        .sidebar {
            width: 250px;
            background: rgba(26, 26, 26, 0.8);
            border-right: 2px solid #00FFFF;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            transition: transform 0.3s ease;
            z-index: 10;
        }

        .sidebar.collapsed {
            transform: translateX(-250px);
        }

        .sidebar-tab {
            position: absolute;
            top: 0;
            right: -40px;
            width: 40px;
            height: 40px;
            background: rgba(26, 26, 26, 0.8);
            border: 2px solid #00FFFF;
            border-left: none;
            border-radius: 0 10px 10px 0;
            color: #00FFFF;
            font-size: 19px;
            line-height: 36px;
            text-align: center;
            cursor: pointer;
            box-shadow: 0 0 8px #00FFFF;
            z-index: 11;
        }

        .sidebar-title {
            font-family: 'Exo 2', sans-serif;
            font-size: 26px;
            color: #DAA520;
            text-align: center;
            text-shadow: 0 0 10px #DAA520;
            line-height: 1.2;
            margin-top: 0;
        }

        .sidebar-title span {
            display: block;
            font-size: 18px;
        }

        .button-container {
            display: flex;
            align-items: center;
            width: 100%;
            position: relative;
        }

        .button-label {
            color: #FFFF00;
            font-size: 13px;
            margin-right: 10px;
            width: 100px;
            text-align: right;
            padding-left: 10px;
        }

        .dropdown-toggle, #control-panel-button {
            background: rgba(26, 26, 26, 0.8);
            border: 2px solid #00FFFF;
            border-radius: 10px;
            color: #00FFFF;
            font-size: 11px;
            padding: 4px 8px;
            width: calc(100% - 120px);
            text-align: center;
            cursor: pointer;
            box-shadow: 0 0 8px #00FFFF;
            transition: background 0.2s ease;
        }

        .dropdown-toggle:hover, #control-panel-button:hover {
            background: rgba(26, 26, 26, 1);
        }

        #time-range-toggle {
            font-size: 10px;
            white-space: nowrap;
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 110px;
            width: calc(100% - 120px);
            max-height: 200px;
            overflow-y: auto;
            background: rgba(26, 26, 26, 0.9);
            border: 2px solid #00FFFF;
            border-radius: 10px;
            color: #00FFFF;
            font-size: 11px;
            padding: 8px;
            z-index: 100;
            display: none;
            box-shadow: 0 0 8px #00FFFF;
        }

        .dropdown-menu.open {
            display: block;
        }

        .dropdown-item {
            display: flex;
            align-items: center;
            margin-bottom: 3px;
        }

        .dropdown-item input[type="checkbox"],
        .dropdown-item input[type="radio"] {
            margin-right: 5px;
        }

        .dropdown-item label {
            cursor: pointer;
        }

        #time-range-menu {
            padding: 10px;
        }

        #time-range-menu .dropdown-item {
            flex-direction: column;
            align-items: flex-start;
            margin-bottom: 10px;
        }

        #time-range-menu input[type="text"] {
            width: 100%;
            background: rgba(26, 26, 26, 0.8);
            border: 1px solid #00FFFF;
            color: #00FFFF;
            padding: 4px;
            margin-top: 5px;
            font-size: 11px;
            border-radius: 5px;
        }

        #stats-menu {
            color: #00FF00;
            font-family: 'VT323', monospace;
            font-size: 15px;
        }

        /* Graph container */
        .graph-container {
            position: absolute;
            right: 0;
            width: calc(100vw - 250px);
            background-color: #1A1A1A;
            height: calc(100vh - 4vh);
            transition: width 0.3s ease, left 0.3s ease;
            z-index: 1;
            overflow: hidden;
            padding-left: 20px;
        }

        .graph-container.full-width {
            width: 100vw;
            left: 0;
            padding-left: 20px;
        }

        #graph {
            width: 100%;
            height: 100%;
            min-width: 320px;
            min-height: 240px;
            position: relative;
            display: block;
            z-index: 1;
            visibility: visible;
            opacity: 1;
        }

        .welcome-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00FF00;
            font-family: 'VT323', monospace;
            font-size: 20px;
            text-align: center;
            text-shadow: 0 0 10px #00FF00;
            z-index: 2;
        }

        .welcome-message img {
            display: block;
            margin: 0 auto;
            max-width: 300px;
            height: auto;
        }

        .welcome-message hr {
            border: 1px solid #00FFFF;
            width: 80%;
            margin: 10px auto;
        }

        /* Metagenomics styles */
        .metagenomics-link {
            display: block;
            padding: 5px 10px;
            text-decoration: none;
            color: #FFFFFF;
            cursor: pointer;
            pointer-events: auto;
            position: relative;
            z-index: 10;
            transition: background 0.2s ease;
        }

        .metagenomics-link:hover {
            background-color: #333;
        }

        .metagenomics-link.active {
            background-color: #555;
            font-weight: bold;
        }

        .metagenomics-subheader {
            color: #DAA520;
            font-size: 12px;
            font-weight: bold;
            padding: 4px 8px;
            width: 100%;
        }

        .kraken-stacked-bar {
            color: #00FF00;
        }

        .kraken-stacked-bar:hover {
            background: rgba(0, 255, 0, 0.2);
        }

        #metagenomics-menu {
            width: calc(100% - 120px);
            left: 110px;
        }

        .metagenomics-popup {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #1A1A1A;
            border: 2px solid #00FFFF;
            border-radius: 10px;
            padding: 0;
            color: #00FFFF;
            font-size: 13px;
            z-index: 10000;
            display: none;
            overflow: hidden;
        }

        .metagenomics-popup h3 {
            color: #DAA520;
            font-family: 'Exo 2', sans-serif;
            font-size: 18px;
            margin: 0;
        }

        /* Controls popup */
        .controls-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(26, 26, 26, 0.9);
            border: 2px solid #00FFFF;
            border-radius: 10px;
            padding: 15px;
            color: #00FFFF;
            font-size: 13px;
            z-index: 20;
            display: none;
            width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 10px #00FFFF;
        }

        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: #1A1A1A;
            border-bottom: 1px solid #444;
            position: sticky;
            top: 0;
            z-index: 10010;
            height: 40px;
            box-sizing: border-box;
        }

        .controls-header h3 {
            color: #DAA520;
            font-family: 'Exo 2', sans-serif;
            font-size: 18px;
            margin: 0;
        }

        .close-button {
            cursor: pointer;
            color: #FF4500;
            font-size: 16px;
            font-weight: bold;
            padding: 0 10px;
        }

        .close-button:hover {
            color: #FF6347;
        }

        #metagenomics-iframe,
        #metagenomics-popup > div:not(.controls-header) {
            margin-top: 40px;
            height: calc(100% - 40px);
            width: 100%;
            box-sizing: border-box;
            z-index: 9999;
            border: none;
        }

        /* Slider styles */
        .slider-container {
            margin: 10px 0;
            position: relative;
        }

        .slider-container label {
            display: block;
            margin-bottom: 5px;
            color: #00FFFF;
        }

        .range-slider {
            position: relative;
            width: 100%;
            height: 5px;
            background: #444;
            border-radius: 5px;
            pointer-events: none;
        }

        .range-track {
            position: absolute;
            height: 5px;
            background: #00FFFF;
            z-index: 1;
        }

        .range-slider input[type="range"] {
            position: absolute;
            width: 100%;
            height: 5px;
            top: -5px;
            background: none;
            -webkit-appearance: none;
            pointer-events: none;
        }

        .range-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            background: #00FFFF;
            border-radius: 50%;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 0 5px #00FFFF;
        }

        .range-slider input[type="range"]::-webkit-slider-runnable-track {
            background: transparent;
        }

        .slider-values {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #00FF00;
            margin-top: 5px;
            pointer-events: none;
        }

        .warning-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FF4500;
            font-family: 'VT323', monospace;
            font-size: 17px;
            text-align: center;
            text-shadow: 0 0 5px #FF4500;
            z-index: 5;
        }

        /* Plot selection popup */
        .plot-selection-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(26, 26, 26, 0.9);
            border: 2px solid #00FFFF;
            border-radius: 10px;
            padding: 15px;
            color: #00FFFF;
            font-size: 13px;
            z-index: 30;
            display: none;
            width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 10px #00FFFF;
        }

        .plot-selection-popup h3 {
            color: #DAA520;
            font-family: 'Exo 2', sans-serif;
            font-size: 18px;
            margin: 0;
        }

        .plot-selection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: #1A1A1A;
            border-bottom: 1px solid #444;
            position: sticky;
            top: 0;
            z-index: 10010;
            height: 40px;
            box-sizing: border-box;
        }

        .plot-selection-content {
            margin-top: 10px;
        }

        .plot-selection-content .dropdown-item {
            margin-bottom: 5px;
        }

        /* Control panel plot selection button */
        .dropdown-container {
            margin: 10px 0;
        }

        .dropdown-container label {
            color: #00FFFF;
            font-size: 13px;
            margin-bottom: 5px;
            display: block;
        }

        #plot-number-button {
            background: rgba(26, 26, 26, 0.8);
            border: 2px solid #00FFFF;
            border-radius: 10px;
            color: #00FFFF;
            font-size: 11px;
            padding: 4px 8px;
            text-align: center;
            cursor: pointer;
            box-shadow: 0 0 8px #00FFFF;
            width: 100%;
            transition: background 0.2s ease;
        }

        #plot-number-button:hover {
            background: rgba(26, 26, 26, 1);
        }

        /* Mobile sidebar button */
        .mobile-sidebar-button {
            display: none;
            position: absolute;
            top: 10px;
            left: 10px;
            width: 40px;
            height: 40px;
            background: rgba(26, 26, 26, 0.8);
            border: 2px solid #00FFFF;
            border-radius: 10px;
            color: #00FFFF;
            font-size: 19px;
            line-height: 36px;
            text-align: center;
            cursor: pointer;
            z-index: 12;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .sidebar {
                width: 200px;
            }

            .graph-container {
                width: calc(100vw - 200px);
            }

            .graph-container.full-width {
                width: 100vw;
            }

            .controls-popup {
                width: 300px;
                font-size: 11px;
            }

            .plot-selection-popup {
                width: 300px;
                font-size: 11px;
            }

            .sidebar-title {
                font-size: 20px;
            }

            .sidebar-title span {
                font-size: 14px;
            }

            .button-label {
                font-size: 11px;
                width: 80px;
            }

            .dropdown-toggle, #control-panel-button, #plot-number-button {
                font-size: 10px;
                width: calc(100% - 90px);
            }

            .dropdown-menu {
                left: 90px;
                width: calc(100% - 90px);
                font-size: 10px;
            }

            #metagenomics-menu {
                width: calc(100% - 90px);
                left: 90px;
            }

            h1 {
                font-size: calc(14px + 1vw);
            }

            .metagenomics-popup {
                width: 90vw;
                padding: 10px;
            }
        }

        @media (max-width: 480px) {
            .sidebar {
                width: 150px;
            }

            .graph-container {
                width: calc(100vw - 150px);
            }

            .graph-container.full-width {
                width: 100vw;
            }

            .controls-popup {
                width: 90vw;
                padding: 10px;
            }

            .plot-selection-popup {
                width: 90vw;
                padding: 10px;
            }

            .sidebar-title {
                font-size: 18px;
            }

            .sidebar-title span {
                font-size: 12px;
            }

            .button-label {
                font-size: 10px;
                width: 70px;
            }

            .dropdown-toggle, #control-panel-button, #plot-number-button {
                font-size: 9px;
                width: calc(100% - 80px);
            }

            .dropdown-menu {
                left: 80px;
                width: calc(100% - 80px);
                font-size: 9px;
            }

            #metagenomics-menu {
                width: calc(100% - 80px);
                left: 80px;
            }

            h1 {
                font-size: calc(12px + 1vw);
            }

            .mobile-sidebar-button {
                display: block;
            }

            .metagenomics-link {
                font-size: 9px;
            }

            .metagenomics-subheader {
                font-size: 10px;
            }

            .metagenomics-popup h3 {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <h1>Comparative Biospheromics Dashboard</h1>
    <div class="container">
        <div class="sidebar" id="sidebar">
            <div class="sidebar-tab" id="sidebar-tab"><</div>
            <div class="sidebar-title">SPRUCE<br><span>Data Explorer</span></div>
            <div class="button-container">
                <span class="button-label">Control Panel:</span>
                <div id="control-panel-button">Show Control Panel</div>
            </div>
            <div class="button-container">
                <span class="button-label">X-Axis:</span>
                <div class="dropdown-toggle" id="independent-toggle">Time</div>
                <div class="dropdown-menu" id="independent-menu">
                    <div class="dropdown-item"><input type="checkbox" id="TIMESTAMP" value="TIMESTAMP" checked><label for="TIMESTAMP">Time</label></div>
                    <div class="dropdown-item"><input type="checkbox" id="TA_2_0" value="TA_2_0"><label for="TA_2_0">Ambient Temp 2m (°C)</label></div>
                    <div class="dropdown-item"><input type="checkbox" id="RH_2_0" value="RH_2_0"><label for="RH_2_0">Relative Humidity 2m (%)</label></div>
                    <div class="dropdown-item"><input type="checkbox" id="WD_10" value="WD_10"><label for="WD_10">Wind Direction 10m (°)</label></div>
                    <div class="dropdown-item"><input type="checkbox" id="PREC_6" value="PREC_6"><label for="PREC_6">Precipitation (mm)</label></div>
                    <div class="dropdown-item"><input type="checkbox" id="CO2_measured" value="CO2_measured"><label for="CO2_measured">Measured CO₂ (ppm)</label></div>
                    <div class="dropdown-item"><input type="checkbox" id="H2O_measured" value="H2O_measured"><label for="H2O_measured">Measured H₂O (mmol/mol)</label></div>
                </div>
            </div>
            <div class="button-container">
                <span class="button-label">Y-Axis:</span>
                <div class="dropdown-toggle" id="dependent-toggle">Select Dependent</div>
                <div class="dropdown-menu" id="dependent-menu">
                    <div class="dropdown-item"><input type="checkbox" id="TS_0" value="TS_0"><label for="TS_0" style="color: #00FFFF;">Soil Temp 0 cm (°C)</label></div>
                    <div class="dropdown-item"><input type="checkbox" id="TS_5" value="TS_5"><label for="TS_5" style="color: #FFFF00;">Soil Temp 5 cm (°C)</label></div>
                    <div class="dropdown-item"><input type="checkbox" id="TS_10" value="TS_10"><label for="TS_10" style="color: #FF00FF;">Soil Temp 10 cm (°C)</label></div>
                    <div class="dropdown-item"><input type="checkbox" id="TS_20" value="TS_20"><label for="TS_20" style="color: #00FF00;">Soil Temp 20 cm (°C)</label></div>
                    <div class="dropdown-item"><input type="checkbox" id="TS_30" value="TS_30"><label for="TS_30" style="color: #FF0000;">Soil Temp 30 cm (°C)</label></div>
                    <div class="dropdown-item"><input type="checkbox" id="TS_40" value="TS_40"><label for="TS_40" style="color: #0000FF;">Soil Temp 40 cm (°C)</label></div>
                    <div class="dropdown-item"><input type="checkbox" id="TS_50" value="TS_50"><label for="TS_50" style="color: #FFA500;">Soil Temp 50 cm (°C)</label></div>
                    <div class="dropdown-item"><input type="checkbox" id="TS_100" value="TS_100"><label for="TS_100" style="color: #800080;">Soil Temp 100 cm (°C)</label></div>
                    <div class="dropdown-item"><input type="checkbox" id="TS_200" value="TS_200"><label for="TS_200" style="color: #008080;">Soil Temp 200 cm (°C)</label></div>
                    <div class="dropdown-item"><input type="checkbox" id="TA_2_0_dep" value="TA_2_0"><label for="TA_2_0_dep" style="color: #FF6347;">Ambient Temp 2m (°C)</label></div>
                    <div class="dropdown-item"><input type="checkbox" id="RH_2_0_dep" value="RH_2_0"><label for="RH_2_0_dep" style="color: #4682B4;">Relative Humidity 2m (%)</label></div>
                    <div class="dropdown-item"><input type="checkbox" id="WD_10_dep" value="WD_10"><label for="WD_10_dep" style="color: #6A5ACD;">Wind Direction 10m (°)</label></div>
                    <div class="dropdown-item"><input type="checkbox" id="PREC_6_dep" value="PREC_6"><label for="PREC_6_dep" style="color: #DAA520;">Precipitation (mm)</label></div>
                    <div class="dropdown-item"><input type="checkbox" id="CO2_measured_dep" value="CO2_measured"><label for="CO2_measured_dep" style="color: #FF69B4;">Measured CO₂ (ppm)</label></div>
                    <div class="dropdown-item"><input type="checkbox" id="H2O_measured_dep" value="H2O_measured"><label for="H2O_measured_dep" style="color: #7FFF00;">Measured H₂O (mmol/mol)</label></div>
                </div>
            </div>
            <div class="button-container">
                <span class="button-label">Time Range:</span>
                <div class="dropdown-toggle" id="time-range-toggle">2015-08-01 - 2025-04-05</div>
                <div class="dropdown-menu" id="time-range-menu">
                    <div class="dropdown-item"><label for="start-date">Start Date:</label><input type="text" id="start-date" value="2015-08-01"></div>
                    <div class="dropdown-item"><label for="end-date">End Date:</label><input type="text" id="end-date" value="2025-04-05"></div>
                </div>
            </div>
            <div class="button-container">
                <span class="button-label">Chart Type:</span>
                <div class="dropdown-toggle" id="chart-type-toggle">Scatter</div>
                <div class="dropdown-menu" id="chart-type-menu">
                    <div class="dropdown-item"><input type="radio" name="chart-type" id="scatter" value="scatter" checked><label for="scatter">Scatter</label></div>
                    <div class="dropdown-item"><input type="radio" name="chart-type" id="line" value="line"><label for="line">Line</label></div>
                    <div class="dropdown-item"><input type="radio" name="chart-type" id="bar" value="bar"><label for="bar">Bar</label></div>
                    <div class="dropdown-item"><input type="radio" name="chart-type" id="area" value="area"><label for="area">Area</label></div>
                    <div class="dropdown-item"><input type="radio" name="chart-type" id="box" value="box"><label for="box">Box</label></div>
                    <div class="dropdown-item"><input type="radio" name="chart-type" id="anova" value="anova"><label for="anova">ANOVA</label></div>
                </div>
            </div>
            <div class="button-container">
                <span class="button-label">Stats:</span>
                <div class="dropdown-toggle" id="stats-toggle">Show Stats</div>
                <div class="dropdown-menu" id="stats-menu">
                    <div id="stats-content"></div>
                    <div class="fit-options" id="fit-options">
                        <div class="dropdown-item"><input type="radio" name="fit-type" id="fit-auto" value="auto" checked><label for="fit-auto">Auto (Best Fit)</label></div>
                        <div class="dropdown-item"><input type="radio" name="fit-type" id="fit-linear" value="linear"><label for="fit-linear">Linear</label></div>
                        <div class="dropdown-item"><input type="radio" name="fit-type" id="fit-exponential" value="exponential"><label for="fit-exponential">Exponential</label></div>
                        <div class="dropdown-item"><input type="radio" name="fit-type" id="fit-logarithmic" value="logarithmic"><label for="fit-logarithmic">Logarithmic</label></div>
                    </div>
                    <div class="dropdown-item"><input type="checkbox" id="show-fit" checked><label for="show-fit">Show Fit</label></div>
                    <div class="dropdown-item"><input type="checkbox" id="show-on-chart"><label for="show-on-chart">Show on Chart</label></div>
                </div>
            </div>
            <div class="button-container">
                <span class="button-label">Metagenomics:</span>
                <div class="dropdown-toggle" id="metagenomics-toggle">Select Visualization</div>
                <div class="dropdown-menu" id="metagenomics-menu">
                    <div class="dropdown-item">
                        <a href="https://aime2solve.github.io/SPRUCE/Metagenomics/multiqc_report.html" class="metagenomics-link">MultiQC Report (FastQC)</a>
                    </div>
                    <div class="dropdown-item">
                        <span class="metagenomics-subheader">Kraken2/Krona Reports</span>
                    </div>
                    <div class="dropdown-item">
                        <a href="https://aime2solve.github.io/SPRUCE/Metagenomics/SRR1157607_krona.html" class="metagenomics-link">SRR1157607 (Kraken2/Krona)</a>
                    </div>
                    <div class="dropdown-item">
                        <a href="https://aime2solve.github.io/SPRUCE/Metagenomics/SRR1157608_krona.html" class="metagenomics-link">SRR1157608 (Kraken2/Krona)</a>
                    </div>
                    <div class="dropdown-item">
                        <a href="https://aime2solve.github.io/SPRUCE/Metagenomics/SRR1157609_krona.html" class="metagenomics-link">SRR1157609 (Kraken2/Krona)</a>
                    </div>
                    <div class="dropdown-item">
                        <a href="https://aime2solve.github.io/SPRUCE/Metagenomics/SRR1157614_krona.html" class="metagenomics-link">SRR1157614 (Kraken2/Krona)</a>
                    </div>
                    <div class="dropdown-item">
                        <a href="https://aime2solve.github.io/SPRUCE/Metagenomics/SRR1157615_krona.html" class="metagenomics-link">SRR1157615 (Kraken2/Krona)</a>
                    </div>
                    <div class="dropdown-item">
                        <a href="https://aime2solve.github.io/SPRUCE/Metagenomics/SRR1157616_krona.html" class="metagenomics-link">SRR1157616 (Kraken2/Krona)</a>
                    </div>
                    <div class="dropdown-item">
                        <a href="https://aime2solve.github.io/SPRUCE/Metagenomics/SRR1157617_krona.html" class="metagenomics-link">SRR1157617 (Kraken2/Krona)</a>
                    </div>
                    <div class="dropdown-item">
                        <span class="metagenomics-subheader">Kraken2 Visualizations</span>
                    </div>
                    <div class="dropdown-item">
                        <a href="#" class="metagenomics-link kraken-stacked-bar">Stacked Bar Chart (Top Taxa)</a>
                    </div>
                </div>
            </div>
        </div>
        <div class="graph-container" id="graph-container">
            <div id="graph">
                <div class="welcome-message" id="welcome-message">
                    <a href="https://mnspruce.ornl.gov" target="_blank"><img src="./SPRUCE_logo.png" alt="SPRUCE Logo"></a>
                    <hr>An experiment to assess the response of northern peatland ecosystems to increases in temperature and exposures to elevated atmospheric CO₂ concentrations.<hr>Beginning August 2015
                </div>
            </div>
        </div>
    </div>
    <div class="controls-popup" id="control-panel-popup">
        <div class="controls-header">
            <h3>Control Panel</h3>
            <div class="close-button" id="close-control-panel">X</div>
        </div>
        <div id="control-panel-content"></div>
    </div>
    <div class="metagenomics-popup" id="metagenomics-popup">
        <div class="controls-header">
            <h3>Metagenomics Visualization</h3>
            <div class="close-button" id="close-metagenomics">X</div>
        </div>
        <iframe id="metagenomics-iframe" style="width: 100%; height: calc(100% - 40px); border: none;"></iframe>
    </div>
    <div class="plot-selection-popup" id="plot-selection-popup">
        <div class="plot-selection-header">
            <h3>Select Plots</h3>
            <div class="close-button" id="close-plot-selection">X</div>
        </div>
        <div class="plot-selection-content" id="plot-selection-content"></div>
    </div>
    <div class="mobile-sidebar-button" id="mobile-sidebar-button">></div>
    


<script>
 
// Global variables
let allData = [];
const dataUrl = 'https://raw.githubusercontent.com/aime2solve/SPRUCE/main/spruce_daily_with_co2_h2o.json';
const metagenomicUrl = 'https://raw.githubusercontent.com/aime2solve/SPRUCE/main/Metagenomics/kraken_taxa.json';
let startDate = new Date('2015-08-01');
let endDate = new Date('2025-04-05');
let dataLoaded = false;
let legendVisible = true;
let cachedData = null;
let graphInitialized = false;
let selectedPlots = [4, 6, 7, 8, 10, 11, 13, 14, 16, 17, 19, 20, 21]; // All plots selected by default

// Color mappings for dependent variables
const dependentColors = {
    TS_0: '#00FFFF', TS_5: '#FFFF00', TS_10: '#FF00FF', TS_20: '#00FF00', TS_30: '#FF0000',
    TS_40: '#0000FF', TS_50: '#FFA500', TS_100: '#800080', TS_200: '#008080',
    TA_2_0: '#FF6347', RH_2_0: '#4682B4', WD_10: '#6A5ACD',
    PREC_6: '#DAA520', CO2_measured: '#FF69B4', H2O_measured: '#7FFF00'
};

// Control ranges for sliders
const controlRanges = {
    TS_200: { min: -10, max: 30, defaultMin: -10, defaultMax: 30, label: 'Soil Temp (°C)' },
    Soil_Depth: { min: 0, max: 200, defaultMin: 0, defaultMax: 200, label: 'Soil Depth (cm)' },
    TA_2_0: { min: -20, max: 40, defaultMin: -20, defaultMax: 40, label: 'Ambient Temp 2m (°C)' },
    CO2_measured: { min: 300, max: 1000, defaultMin: 300, defaultMax: 1000, label: 'Measured CO₂ (ppm)' },
    H2O_measured: { min: 0, max: 30, defaultMin: 0, defaultMax: 30, label: 'Measured H₂O (mmol/mol)' },
    RH_2_0: { min: 0, max: 100, defaultMin: 0, defaultMax: 100, label: 'Relative Humidity 2m (%)' },
    WD_10: { min: 0, max: 360, defaultMin: 0, defaultMax: 360, label: 'Wind Direction 10m (°)' },
    PREC_6: { min: 0, max: 100, defaultMin: 0, defaultMax: 100, label: 'Precipitation (mm)' }
};
let currentRanges = JSON.parse(JSON.stringify(controlRanges));
let depthRange = [0, 200];

// Unit mappings
const unitMap = {
    TS_0: '°C', TS_5: '°C', TS_10: '°C', TS_20: '°C', TS_30: '°C',
    TS_40: '°C', TS_50: '°C', TS_100: '°C', TS_200: '°C', TA_2_0: '°C',
    RH_2_0: '%', WD_10: '°', PREC_6: 'mm',
    CO2_measured: 'ppm', H2O_measured: 'mmol/mol'
};

// Plot conditions
const plotConditions = {
    4: { temp: '+9°C', co2: 'Amb', chamber: 'Enc' },
    6: { temp: '+0°C', co2: 'Amb', chamber: 'Enc' },
    7: { temp: 'Amb', co2: 'Amb', chamber: 'Open' },
    8: { temp: '+6.8°C', co2: 'Amb', chamber: 'Enc' },
    10: { temp: '+4.5°C', co2: 'Amb', chamber: 'Enc' },
    11: { temp: '+0°C', co2: '900', chamber: 'Enc' },
    13: { temp: '+2.3°C', co2: 'Amb', chamber: 'Enc' },
    14: { temp: 'Amb', co2: 'Amb', chamber: 'Open' },
    16: { temp: '+6.8°C', co2: '900', chamber: 'Enc' },
    17: { temp: '+4.5°C', co2: '900', chamber: 'Enc' },
    19: { temp: '+9°C', co2: '900', chamber: 'Enc' },
    20: { temp: '+2.3°C', co2: '900', chamber: 'Enc' },
    21: { temp: 'Amb', co2: 'Amb', chamber: 'Open' }
};

// Metagenomic sample to plot mappings
const sampleToPlotMap = {
    'SRR1157607': { depth: 'SP0212_75cm', plot: 4, collection_date: '2020-07-15' },
    'SRR1157608': { depth: 'SP0212_25cm', plot: 6, collection_date: '2020-07-15' },
    'SRR1157609': { depth: 'SP0212_50cm', plot: 7, collection_date: '2020-07-15' },
    'SRR1157614': { depth: 'SP0212_100cm', plot: 8, collection_date: '2020-07-15' },
    'SRR1157615': { depth: 'SP0212_10cm', plot: 10, collection_date: '2020-07-15' },
    'SRR1157616': { depth: 'SP0212_150cm', plot: 11, collection_date: '2020-07-15' },
    'SRR1157617': { depth: 'SP0212_200cm', plot: 13, collection_date: '2020-07-15' }
};

// Load data from JSON
async function loadData() {
    const graphDiv = document.getElementById('graph');
    if (!graphDiv) {
        console.error('Graph div not found');
        return;
    }
    graphDiv.innerHTML = '<div class="welcome-message" id="welcome-message">Loading data...</div>';
    try {
        const response = await fetch(dataUrl);
        if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
        allData = await response.json();
        allData = allData.map(row => {
            const year = parseInt(row.Year, 10);
            const dfoy = parseFloat(row.DFOY);
            const day = Math.floor(dfoy);
            const fractionalDay = dfoy - day;
            const date = new Date(year, 0);
            date.setDate(day);
            date.setHours(Math.floor(fractionalDay * 24), Math.floor((fractionalDay * 24 % 1) * 60), 0, 0);
            row.TIMESTAMP = date;
            row.Plot = Number(row.Plot);
            return row;
        }).filter(row => !isNaN(row.TIMESTAMP.getTime()) && row.TIMESTAMP instanceof Date && !isNaN(row.Plot));
        dataLoaded = true;
        cachedData = aggregateVariables(allData);
        resetGraph();
    } catch (error) {
        console.error('Error loading data:', error);
        graphDiv.innerHTML = '<div class="warning-message">Failed to load data. Check console for details.</div>';
    }
}

// Reset graph to welcome message
function resetGraph() {
    const graphDiv = document.getElementById('graph');
    if (!graphDiv) return;
    if (graphInitialized) {
        Plotly.purge(graphDiv);
        graphInitialized = false;
    }
    graphDiv.innerHTML = '<div class="welcome-message" id="welcome-message"><a href="https://mnspruce.ornl.gov" target="_blank"><img src="./SPRUCE_logo.png" alt="SPRUCE Logo"></a><hr>An experiment to assess the response of northern peatland ecosystems to increases in temperature and exposures to elevated atmospheric CO₂ concentrations.<hr>Beginning August 2015</div>';
}

// Toggle dropdown menu visibility
function toggleDropdown(id) {
    const menus = document.querySelectorAll('.dropdown-menu');
    menus.forEach(menu => {
        if (menu.id !== id && menu.classList.contains('open')) {
            menu.classList.remove('open');
        }
    });
    const menu = document.getElementById(id);
    if (menu) {
        menu.classList.toggle('open');
        console.log(`Toggled dropdown: ${id}, now ${menu.classList.contains('open') ? 'open' : 'closed'}`);
        if (id === 'stats-menu' && menu.classList.contains('open')) {
            updateStatsOptions();
            updateGraph();
        }
    }
}

// Toggle sidebar visibility
function toggleSidebar() {
    const sidebar = document.getElementById('sidebar');
    const graphContainer = document.getElementById('graph-container');
    const tab = document.getElementById('sidebar-tab');
    const mobileButton = document.getElementById('mobile-sidebar-button');
    if (sidebar && graphContainer && tab && mobileButton) {
        sidebar.classList.toggle('collapsed');
        graphContainer.classList.toggle('full-width');
        tab.textContent = sidebar.classList.contains('collapsed') ? '>' : '<';
        mobileButton.style.display = sidebar.classList.contains('collapsed') && window.innerWidth <= 480 ? 'block' : 'none';
        if (dataLoaded && graphInitialized) {
            Plotly.relayout('graph', {
                width: calculateGraphWidth(),
                height: calculateGraphHeight()
            });
        }
    }
}

// Enforce single checkbox selection for independent variable
function enforceSingleSelection(groupId, changedId) {
    const checkboxes = document.querySelectorAll(`#${groupId} input[type="checkbox"]`);
    checkboxes.forEach(checkbox => {
        if (checkbox.id !== changedId && checkbox.checked) {
            checkbox.checked = false;
        }
    });
}

// Filter data by control ranges
function filterByRanges(data) {
    return data.filter(row => {
        return Object.keys(currentRanges).every(key => {
            if (key === 'Soil_Depth') return true;
            const value = parseFloat(row[key]);
            const range = currentRanges[key];
            return isNaN(value) || (value >= range.defaultMin && value <= range.defaultMax);
        });
    });
}

// Filter data by soil depth range
function filterByDepthRange(data) {
    const depths = [0, 5, 10, 20, 30, 40, 50, 100, 200];
    return data.map(row => {
        const newRow = { ...row };
        depths.forEach(depth => {
            if (depth < depthRange[0] || depth > depthRange[1]) {
                newRow[`TS_${depth}`] = null;
            }
        });
        return newRow;
    });
}

// Toggle control panel visibility
function toggleControlPanel() {
    const popup = document.getElementById('control-panel-popup');
    const content = document.getElementById('control-panel-content');
    const button = document.getElementById('control-panel-button');
    if (!popup || !content || !button) {
        console.error('Control panel elements missing');
        return;
    }
    const isVisible = popup.style.display === 'block';
    popup.style.display = isVisible ? 'none' : 'block';
    button.textContent = isVisible ? 'Show Control Panel' : 'Hide Control Panel';

    if (!isVisible) {
        let slidersHtml = Object.keys(controlRanges).map(key => {
            return `
                <div class="slider-container">
                    <label>${controlRanges[key].label}</label>
                    <div class="range-slider">
                        <div class="range-track" id="${key}-track"></div>
                        <input type="range" id="${key}-min" min="${controlRanges[key].min}" max="${controlRanges[key].max}" value="${currentRanges[key].defaultMin}" step="${key === 'Soil_Depth' ? 5 : 0.1}">
                        <input type="range" id="${key}-max" min="${controlRanges[key].min}" max="${controlRanges[key].max}" value="${currentRanges[key].defaultMax}" step="${key === 'Soil_Depth' ? 5 : 0.1}">
                    </div>
                    <div class="slider-values">
                        <span id="${key}-min-value">${currentRanges[key].defaultMin}</span>
                        <span id="${key}-max-value">${currentRanges[key].defaultMax}</span>
                    </div>
                </div>
            `;
        }).join('');

        slidersHtml += `
            <div class="dropdown-container">
                <label>Plot Selection</label>
                <button id="plot-number-button" class="dropdown-toggle">Plot # (${selectedPlots.length ? selectedPlots.join(', ') : 'all'})</button>
            </div>
        `;

        content.innerHTML = slidersHtml;

        Object.keys(controlRanges).forEach(key => {
            const minSlider = document.getElementById(`${key}-min`);
            const maxSlider = document.getElementById(`${key}-max`);
            const track = document.getElementById(`${key}-track`);
            const minValue = document.getElementById(`${key}-min-value`);
            const maxValue = document.getElementById(`${key}-max-value`);

            if (!minSlider || !maxSlider || !track || !minValue || !maxValue) {
                console.warn(`Slider elements missing for ${key}`);
                return;
            }

            function updateTrack() {
                const min = parseFloat(minSlider.value);
                const max = parseFloat(maxSlider.value);
                const minPercent = ((min - controlRanges[key].min) / (controlRanges[key].max - controlRanges[key].min)) * 100;
                const maxPercent = ((max - controlRanges[key].min) / (controlRanges[key].max - controlRanges[key].min)) * 100;
                track.style.left = `${minPercent}%`;
                track.style.width = `${maxPercent - minPercent}%`;
                minValue.textContent = min.toFixed(1);
                maxValue.textContent = max.toFixed(1);
            }

            minSlider.addEventListener('input', () => {
                let min = parseFloat(minSlider.value);
                let max = parseFloat(maxSlider.value);
                if (min > max) min = max;
                minSlider.value = min;
                currentRanges[key].defaultMin = min;
                if (key === 'Soil_Depth') depthRange[0] = min;
                updateTrack();
                updateGraph();
            });

            maxSlider.addEventListener('input', () => {
                let min = parseFloat(minSlider.value);
                let max = parseFloat(maxSlider.value);
                if (max < min) max = min;
                maxSlider.value = max;
                currentRanges[key].defaultMax = max;
                if (key === 'Soil_Depth') depthRange[1] = max;
                updateTrack();
                updateGraph();
            });

            updateTrack();
        });

        const plotNumberButton = document.getElementById('plot-number-button');
        if (plotNumberButton) {
            plotNumberButton.addEventListener('click', togglePlotSelectionPopup);
            console.log('Plot number button initialized');
        } else {
            console.error('Plot number button not found after rendering');
        }
    }
}

// Toggle plot selection popup
function togglePlotSelectionPopup() {
    const popup = document.getElementById('plot-selection-popup');
    const content = document.getElementById('plot-selection-content');
    const plotNumberButton = document.getElementById('plot-number-button');
    if (!popup || !content || !plotNumberButton) {
        console.error('Plot selection popup elements missing');
        return;
    }
    const isVisible = popup.style.display === 'block';
    popup.style.display = isVisible ? 'none' : 'block';
    console.log(`Plot selection popup toggled, now ${isVisible ? 'closed' : 'open'}`);

    if (!isVisible) {
        const plotsHtml = Object.entries(plotConditions).map(([plot, cond]) => {
            return `
                <div class="dropdown-item">
                    <input type="checkbox" id="plot-${plot}" value="${plot}" ${selectedPlots.includes(Number(plot)) ? 'checked' : ''}>
                    <label for="plot-${plot}">Plot ${plot} (Temp: ${cond.temp}, CO₂: ${cond.co2}, Chamber: ${cond.chamber})</label>
                </div>
            `;
        }).join('');
        content.innerHTML = plotsHtml;

        content.addEventListener('change', (e) => {
            if (e.target.type === 'checkbox') {
                selectedPlots = Array.from(document.querySelectorAll('#plot-selection-content input:checked')).map(input => Number(input.value));
                plotNumberButton.textContent = selectedPlots.length ? `Plot # (${selectedPlots.join(', ')})` : 'Plot # (all)';
                console.log('Selected plots updated:', selectedPlots);
                updateGraph();
                updateMetagenomics();
            }
        }, { once: false });
    }
}

// Calculate statistical fit
function calculateFit(x, y, fitType) {
    const pairedData = x.map((xi, i) => ({ x: xi, y: y[i] }))
        .filter(d => !isNaN(d.x) && !isNaN(d.y) && d.x !== null && d.y !== null && d.x > 0);
    if (pairedData.length < 2) {
        console.log('Insufficient data for fit:', pairedData.length);
        return { type: 'none', params: {}, rSquared: NaN, pValue: NaN, fValue: NaN, yPred: [] };
    }

    const xNum = pairedData.map(d => d.x);
    const yNum = pairedData.map(d => d.y);
    const n = pairedData.length;

    const fits = {};
    const defaultResult = { type: 'none', params: {}, rSquared: NaN, pValue: NaN, fValue: NaN, yPred: [] };

    const linearFit = () => {
        const sumX = xNum.reduce((a, b) => a + b, 0);
        const sumY = yNum.reduce((a, b) => a + b, 0);
        const sumXY = pairedData.reduce((sum, d) => sum + d.x * d.y, 0);
        const sumXX = xNum.reduce((sum, d) => sum + d * d, 0);
        const denominator = n * sumXX - sumX * sumX;
        if (!isFinite(denominator) || denominator === 0) {
            console.log('Linear fit failed: invalid denominator');
            return null;
        }
        const slope = (n * sumXY - sumX * sumY) / denominator;
        const intercept = (sumY - slope * sumX) / n;
        if (!isFinite(slope) || !isFinite(intercept)) {
            console.log('Linear fit failed: non-finite slope or intercept');
            return null;
        }
        const yPred = xNum.map(x => slope * x + intercept);
        return calculateStats(xNum, yNum, yPred, 'linear', { slope, intercept });
    };

    const logFit = () => {
        const logX = xNum.map(x => Math.log(x));
        const sumLogX = logX.reduce((a, b) => a + b, 0);
        const sumY = yNum.reduce((a, b) => a + b, 0);
        const sumLogXY = pairedData.reduce((sum, d) => sum + Math.log(d.x) * d.y, 0);
        const sumLogXLogX = logX.reduce((sum, d) => sum + d * d, 0);
        const denominator = n * sumLogXLogX - sumLogX * sumLogX;
        if (!isFinite(denominator) || denominator === 0) {
            console.log('Logarithmic fit failed: invalid denominator');
            return null;
        }
        const slope = (n * sumLogXY - sumLogX * sumY) / denominator;
        const intercept = (sumY - slope * sumLogX) / n;
        if (!isFinite(slope) || !isFinite(intercept)) {
            console.log('Logarithmic fit failed: non-finite slope or intercept');
            return null;
        }
        const yPred = xNum.map(x => slope * Math.log(x) + intercept);
        return calculateStats(xNum, yNum, yPred, 'logarithmic', { slope, intercept });
    };

    const expFit = () => {
        const validPairs = pairedData.filter(d => d.y > 0);
        if (validPairs.length < 2) {
            console.log('Exponential fit failed: insufficient positive y values', validPairs.length);
            return null;
        }
        const xExp = validPairs.map(d => d.x);
        const logY = validPairs.map(d => Math.log(d.y));
        const sumX = xExp.reduce((a, b) => a + b, 0);
        const sumLogY = logY.reduce((a, b) => a + b, 0);
        const sumXLogY = validPairs.reduce((sum, d) => sum + d.x * Math.log(d.y), 0);
        const sumXX = xExp.reduce((sum, d) => sum + d * d, 0);
        const denominator = n * sumXX - sumX * sumX;
        if (!isFinite(denominator) || denominator === 0) {
            console.log('Exponential fit failed: invalid denominator');
            return null;
        }
        const slope = (n * sumXLogY - sumX * sumLogY) / denominator;
        const intercept = (sumLogY - slope * sumX) / n;
        const a = Math.exp(intercept);
        const b = slope;
        if (!isFinite(a) || !isFinite(b)) {
            console.log('Exponential fit failed: non-finite parameters');
            return null;
        }
        const yPred = xNum.map(x => a * Math.exp(b * x));
        return calculateStats(xNum, yNum, yPred, 'exponential', { a, b });
    };

    if (fitType === 'auto') {
        fits.linear = linearFit();
        fits.logarithmic = logFit();
        fits.exponential = expFit();
        const validFits = Object.entries(fits)
            .filter(([_, fit]) => fit && !isNaN(fit.rSquared))
            .map(([type, fit]) => ({ type, ...fit }));
        if (validFits.length === 0) {
            console.log('No valid fits found');
            return defaultResult;
        }
        return validFits.reduce((best, current) => (best.rSquared > current.rSquared) ? best : current);
    } else {
        switch (fitType) {
            case 'linear': return linearFit() || defaultResult;
            case 'logarithmic': return logFit() || defaultResult;
            case 'exponential': return expFit() || defaultResult;
            default: return defaultResult;
        }
    }
}

// Calculate regression statistics
function calculateStats(xNum, yNum, yPred, type, params) {
    const n = xNum.length;
    const meanY = yNum.reduce((a, b) => a + b, 0) / n;
    const ssTot = yNum.reduce((sum, d) => sum + Math.pow(d - meanY, 2), 0);
    const ssRes = xNum.reduce((sum, _, i) => sum + Math.pow(yNum[i] - yPred[i], 2), 0);
    const rSquared = ssTot === 0 ? NaN : 1 - (ssRes / ssTot);
    const dfReg = 1;
    const dfRes = n - (dfReg + 1);
    const msReg = (ssTot - ssRes) / dfReg;
    const msRes = ssRes / dfRes;
    const fValue = msRes === 0 ? NaN : msReg / msRes;
    const pValue = isNaN(fValue) ? NaN : jStat.ftest(fValue, dfReg, dfRes);
    if (isNaN(fValue)) {
        console.log('p-value NaN due to invalid F-value', { msReg, msRes });
    }

    if (yPred.some(y => !isFinite(y))) {
        console.log('Invalid yPred values in fit', type);
        return { type: 'none', params: {}, rSquared: NaN, pValue: NaN, fValue: NaN, yPred: [] };
    }
    return { type, params, rSquared, fValue, pValue, yPred };
}

// Calculate ANOVA statistics
function calculateANOVA(data, independent, dependent) {
    const groups = {};
    data.forEach(row => {
        const group = row[independent];
        if (!groups[group]) groups[group] = [];
        const value = parseFloat(row[dependent]);
        if (!isNaN(value)) groups[group].push(value);
    });
    const groupArrays = Object.values(groups).filter(arr => arr.length > 0);
    if (groupArrays.length < 2) {
        return { fScore: NaN, pValue: NaN, means: [], groupNames: [] };
    }
    const fScore = jStat.anovafscore(...groupArrays);
    const pValue = jStat.anovaftest(...groupArrays);
    const means = groupArrays.map(arr => jStat.mean(arr));
    const groupNames = Object.keys(groups).filter(key => groups[key].length > 0);
    return { fScore, pValue, means, groupNames };
}

// Calculate box plot statistics
function calculateBoxStats(yValues) {
    const validY = yValues.filter(y => !isNaN(y) && y !== null);
    if (validY.length === 0) {
        return { median: NaN, q1: NaN, q3: NaN, iqr: NaN, min: NaN, max: NaN };
    }
    const median = jStat.median(validY);
    const q1 = jStat.percentile(validY, 0.25);
    const q3 = jStat.percentile(validY, 0.75);
    const iqr = q3 - q1;
    const lowerBound = q1 - 1.5 * iqr;
    const upperBound = q3 + 1.5 * iqr;
    const min = Math.max(Math.min(...validY), lowerBound);
    const max = Math.min(Math.max(...validY), upperBound);
    return { median, q1, q3, iqr, min, max };
}

// Aggregate variables across zones
function aggregateVariables(data) {
    const depths = [0, 5, 10, 20, 30, 40, 50, 100, 200];
    const zones = ['A', 'B', 'C'];
    return data.map(row => {
        const newRow = { ...row };
        depths.forEach(depth => {
            const suffix = depth === 0 ? 1 : depth === 5 ? 2 : depth === 10 ? 3 : depth === 20 ? 4 : depth === 30 ? 5 : depth === 40 ? 6 : depth === 50 ? 7 : depth === 100 ? 8 : 9;
            const keys = zones.map(zone => `TS_${depth}_${zone}${suffix}`);
            const values = keys.map(k => parseFloat(row[k])).filter(v => !isNaN(v));
            newRow[`TS_${depth}`] = values.length > 0 ? values.reduce((sum, v) => sum + v, 0) / values.length : null;
        });
        const taKeys = ['TA_2_0_1', 'TA_2_0_2'];
        const taValues = taKeys.map(k => parseFloat(row[k])).filter(v => !isNaN(v));
        newRow.TA_2_0 = taValues.length > 0 ? taValues.reduce((sum, v) => sum + v, 0) / taValues.length : null;
        const rhKeys = ['RH_2_0_1', 'RH_2_0_2'];
        const rhValues = rhKeys.map(k => parseFloat(row[k])).filter(v => !isNaN(v));
        newRow.RH_2_0 = rhValues.length > 0 ? rhValues.reduce((sum, v) => sum + v, 0) / rhValues.length : null;
        ['CO2_measured', 'H2O_measured', 'WD_10', 'PREC_6'].forEach(key => {
            const value = parseFloat(row[key]);
            newRow[key] = isNaN(value) ? null : value;
        });
        return newRow;
    });
}

// Aggregate data by week
function getWeeklyTimestamps(data, start, end) {
    const weeklyData = {};
    data.forEach(row => {
        const date = row.TIMESTAMP;
        if ((!start || date >= start) && (!end || date <= new Date(end.getTime() + 24 * 60 * 60 * 1000 - 1))) {
            const weekStart = new Date(date);
            weekStart.setDate(weekStart.getDate() - weekStart.getDay());
            weekStart.setHours(0, 0, 0, 0);
            const key = weekStart.getTime();
            if (!weeklyData[key]) {
                weeklyData[key] = { TIMESTAMP: weekStart, values: {} };
            }
            Object.keys(row).forEach(k => {
                if (k !== 'TIMESTAMP') {
                    weeklyData[key].values[k] = weeklyData[key].values[k] || [];
                    const value = parseFloat(row[k]);
                    if (!isNaN(value)) {
                        weeklyData[key].values[k].push(value);
                    }
                }
            });
        }
    });
    return Object.values(weeklyData).map(w => {
        return {
            TIMESTAMP: w.TIMESTAMP,
            ...Object.keys(w.values).reduce((acc, k) => {
                acc[k] = w.values[k].length > 0 ? w.values[k].reduce((sum, v) => sum + v, 0) / w.values[k].length : null;
                return acc;
            }, {})
        };
    });
}

// Calculate graph dimensions
function calculateGraphWidth() {
    const container = document.getElementById('graph-container');
    return container ? container.clientWidth : window.innerWidth;
}

function calculateGraphHeight() {
    const headerHeight = document.querySelector('h1')?.offsetHeight || 60;
    return window.innerHeight - headerHeight;
}

// Filter outliers using IQR
function filterOutliers(x, y) {
    const pairedData = x.map((xi, i) => ({ x: xi, y: y[i] }))
        .filter(d => !isNaN(d.y) && d.y !== null && !isNaN(d.x) && d.x !== null);
    if (pairedData.length < 2) return { x, y };
    const yValues = pairedData.map(d => d.y);
    const q1 = jStat.percentile(yValues, 0.25);
    const q3 = jStat.percentile(yValues, 0.75);
    const iqr = q3 - q1;
    const lowerBound = q1 - 1.5 * iqr;
    const upperBound = q3 + 1.5 * iqr;
    const filtered = pairedData.filter(d => d.y >= lowerBound && d.y <= upperBound);
    return { x: filtered.map(d => d.x), y: filtered.map(d => d.y) };
}

// Update stats options visibility
function updateStatsOptions() {
    const chartType = document.querySelector('#chart-type-menu input:checked')?.value;
    const fitOptions = document.getElementById('fit-options');
    if (fitOptions) {
        fitOptions.style.display = ['scatter', 'line', 'area'].includes(chartType) ? 'block' : 'none';
    }
}

// Load metagenomic data
async function loadMetagenomicData() {
    try {
        const response = await fetch(metagenomicUrl);
        if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
        const data = await response.json();
        console.log('Metagenomic data loaded:', Object.keys(data).length, 'samples');
        return data;
    } catch (error) {
        console.error('Error loading metagenomic data:', error);
        const graphDiv = document.getElementById('graph');
        if (graphDiv) {
            graphDiv.innerHTML = '<div class="warning-message">Failed to load metagenomic data. Please check the data source URL or try again later.</div>';
        }
        return null;
    }
}

// Show stacked bar chart for metagenomics
async function showStackedBarChart(e) {
    e.preventDefault();
    const graphDiv = document.getElementById('graph');
    if (!graphDiv) {
        console.error('Graph div not found');
        return;
    }

    graphDiv.innerHTML = '<div class="welcome-message">Loading metagenomic data...</div>';

    const data = await loadMetagenomicData();
    if (!data) {
        console.warn('No metagenomic data loaded');
        return;
    }

    console.log('Selected plots:', selectedPlots);
    console.log('Available samples:', Object.keys(data));
    console.log('Sample to plot mapping:', sampleToPlotMap);

    const filteredSamples = Object.keys(data).filter(sample => {
        const plot = sampleToPlotMap[sample]?.plot;
        const isValid = !selectedPlots.length || (plot && selectedPlots.includes(plot));
        console.log(`Sample ${sample}: plot=${plot}, included=${isValid}`);
        return isValid;
    });

    if (!filteredSamples.length) {
        graphDiv.innerHTML = '<div class="warning-message">No metagenomic data for selected plots. Ensure plots like 4, 6, 7, 8, 10, 11, or 13 are selected.</div>';
        console.warn('No samples available for selected plots', { selectedPlots, availablePlots: Object.values(sampleToPlotMap).map(s => s.plot) });
        return;
    }

    const taxa = [...new Set(filteredSamples.flatMap(sample => Object.keys(data[sample] || {})))].slice(0, 10);
    console.log('Extracted taxa:', taxa);

    if (!taxa.length) {
        graphDiv.innerHTML = '<div class="warning-message">No taxa data available for selected samples.</div>';
        console.warn('No taxa found in data for samples:', filteredSamples);
        return;
    }

    const traces = taxa.map((taxon, index) => {
        return {
            x: filteredSamples.map(sample => `${sample} (${sampleToPlotMap[sample]?.depth || 'Unknown'})`),
            y: filteredSamples.map(sample => (data[sample] && data[sample][taxon] !== undefined) ? data[sample][taxon] : 0),
            name: taxon,
            type: 'bar',
            marker: { color: dependentColors[Object.keys(dependentColors)[index % Object.keys(dependentColors).length]] || '#FFFFFF' }
        };
    });

    const layout = {
        title: { text: 'Top Taxa by Sample', font: { color: '#FFFFFF', size: 16, family: 'Exo 2' } },
        barmode: 'stack',
        xaxis: { 
            title: 'Samples (Depth)', 
            tickangle: 45, 
            color: '#FFFFFF', 
            tickfont: { family: 'Exo 2', size: 12 }
        },
        yaxis: { 
            title: 'Relative Abundance (%)', 
            color: '#FFFFFF', 
            tickfont: { family: 'Exo 2', size: 12 }
        },
        paper_bgcolor: '#1A1A1A',
        plot_bgcolor: '#1A1A1A',
        font: { color: '#FFFFFF', family: 'Exo 2' },
        showlegend: true,
        legend: { font: { family: 'Exo 2', size: 12 } },
        margin: { b: 150, l: 100, t: 50, r: 50 },
        width: calculateGraphWidth(),
        height: calculateGraphHeight()
    };

    try {
        Plotly.newPlot(graphDiv, traces, layout, { responsive: true });
        graphInitialized = true;
        console.log('Stacked bar chart plotted successfully with', traces.length, 'taxa');
    } catch (error) {
        console.error('Error plotting stacked bar chart:', error);
        graphDiv.innerHTML = '<div class="warning-message">Error rendering stacked bar chart. Check console for details.</div>';
    }
}

// Update metagenomics menu based on selected plots
function updateMetagenomics() {
    const metagenomicsMenu = document.getElementById('metagenomics-menu');
    if (!metagenomicsMenu) {
        console.error('Metagenomics menu not found');
        return;
    }

    const links = metagenomicsMenu.querySelectorAll('.metagenomics-link:not(.kraken-stacked-bar)');
    links.forEach(link => {
        const sampleId = link.href.match(/SRR\d+/)?.[0];
        const isMultiQC = link.href.includes('multiqc_report.html');
        if (!sampleId || isMultiQC) {
            link.style.display = 'block';
            return;
        }
        const plotNumber = sampleToPlotMap[sampleId]?.plot;
        link.style.display = (!selectedPlots.length || (plotNumber && selectedPlots.includes(plotNumber))) ? 'block' : 'none';
    });
}

// Update graph based on selections
function updateGraph() {
    const graphDiv = document.getElementById('graph');
    if (!graphDiv) {
        console.error('Graph div not found');
        return;
    }
    if (!dataLoaded || typeof Plotly === 'undefined') {
        console.warn('Data not loaded or Plotly undefined');
        resetGraph();
        return;
    }

    try {
        const independent = document.querySelector('#independent-menu input:checked')?.value || null;
        const allDependents = Array.from(document.querySelectorAll('#dependent-menu input:checked')).map(input => input.value);
        const chartType = document.querySelector('#chart-type-menu input:checked')?.value || 'scatter';
        const fitType = document.querySelector('#fit-options input:checked')?.value || 'auto';
        const showFit = document.getElementById('show-fit')?.checked || false;
        const showOnChart = document.getElementById('show-on-chart')?.checked || false;

        console.log('Selections:', { independent, allDependents, chartType, fitType, selectedPlots, showOnChart });

        const independentToggle = document.getElementById('independent-toggle');
        const dependentToggle = document.getElementById('dependent-toggle');
        if (independentToggle) {
            independentToggle.textContent = independent ? document.querySelector(`label[for="${independent}"]`)?.textContent || 'Select Independent' : 'Select Independent';
        }
        if (dependentToggle) {
            dependentToggle.innerHTML = allDependents.length ? allDependents.map(dep => `<span style="color: ${dependentColors[dep]}">${document.querySelector(`label[for="${dep}"], label[for="${dep}_dep"]`)?.textContent}</span>`).join('<br>') : 'Select Dependent';
        }

        if (!allDependents.length || !independent) {
            console.warn('No dependents or independent selected');
            resetGraph();
            return;
        }

        let workingData = filterByRanges(cachedData);
        workingData = filterByDepthRange(workingData);
        workingData = workingData.filter(row => {
            const rowDate = row.TIMESTAMP;
            return (!startDate || rowDate >= startDate) &&
                   (!endDate || rowDate <= new Date(endDate.getTime() + 24 * 60 * 60 * 1000 - 1)) &&
                   (selectedPlots.length === 0 || selectedPlots.includes(row.Plot));
        });

        if (!workingData.length) {
            console.warn('No data after filtering');
            graphDiv.innerHTML = '<div class="warning-message">No data available for selected plots and filters.</div>';
            return;
        }

        if (independent === 'TIMESTAMP' && ['scatter', 'line', 'area'].includes(chartType)) {
            workingData = getWeeklyTimestamps(workingData, startDate, endDate);
        }

        const units = allDependents.map(dep => unitMap[dep]);
        const commonUnit = units.every(u => u === units[0]) ? units[0] : null;
        const dependents = commonUnit ? allDependents.filter(dep => unitMap[dep] === commonUnit) : allDependents;
        if (!dependents.length) {
            console.warn('No valid dependents');
            resetGraph();
            return;
        }

        const traces = [];
        const fitTraces = [];
        let invalidTraces = [];
        const statsText = [];

        if (chartType === 'anova' && dependents.length === 1) {
            const anovaResults = calculateANOVA(workingData, independent, dependents[0]);
            if (isNaN(anovaResults.fScore)) {
                console.warn('Insufficient data for ANOVA');
                graphDiv.innerHTML = '<div class="warning-message">Insufficient data for ANOVA</div>';
                graphInitialized = false;
                return;
            }
            traces.push({
                x: anovaResults.groupNames,
                y: anovaResults.means,
                type: 'bar',
                name: `${document.querySelector(`label[for="${dependents[0]}"], label[for="${dependents[0]}_dep"]`)?.textContent || dependents[0]} Means`,
                marker: { color: dependentColors[dependents[0]] || '#00FFFF' }
            });
            statsText.push({
                text: `${document.querySelector(`label[for="${dependents[0]}"], label[for="${dependents[0]}_dep"]`)?.textContent || dependents[0]}: F-Score=${anovaResults.fScore.toFixed(2)}, p-value=${anovaResults.pValue.toFixed(4)}`,
                color: dependentColors[dependents[0]] || '#00FFFF'
            });
        } else {
            dependents.forEach(dep => {
                const pairedData = workingData
                    .map(row => ({
                        x: independent === 'TIMESTAMP' ? row.TIMESTAMP : parseFloat(row[independent]),
                        y: parseFloat(row[dep])
                    }))
                    .filter(d => d.x !== null && !isNaN(d.x) && d.y !== null && !isNaN(d.y));

                if (pairedData.length < 2) {
                    console.warn(`No valid data for ${dep} vs ${independent}`);
                    invalidTraces.push(`${document.querySelector(`label[for="${dep}"], label[for="${dep}_dep"]`)?.textContent || dep} has no valid data`);
                    return;
                }

                let xValues = pairedData.map(d => d.x);
                let yValues = pairedData.map(d => d.y);

                const filtered = filterOutliers(xValues, yValues);
                xValues = filtered.x;
                yValues = filtered.y;

                if (xValues.length < 2 || yValues.length < 2) {
                    console.warn(`Insufficient data after outlier filtering for ${dep}`);
                    invalidTraces.push(`${document.querySelector(`label[for="${dep}"], label[for="${dep}_dep"]`)?.textContent || dep} has insufficient data after filtering`);
                    return;
                }

                const color = dependentColors[dep] || '#FFFFFF';
                traces.push({
                    x: xValues,
                    y: yValues,
                    mode: chartType === 'scatter' ? 'markers' : chartType === 'line' ? 'lines' : chartType === 'area' ? 'lines' : chartType === 'box' ? 'box' : 'bar',
                    type: chartType === 'scatter' ? 'scatter' : chartType === 'area' ? 'scatter' : chartType,
                    name: document.querySelector(`label[for="${dep}"], label[for="${dep}_dep"]`)?.textContent || dep,
                    marker: { color: color, size: 8 },
                    line: (chartType === 'line' || chartType === 'area') ? { color: color, width: 2 } : undefined,
                    fill: chartType === 'area' ? 'tozeroy' : undefined
                });

                if (chartType === 'box') {
                    const boxStats = calculateBoxStats(yValues);
                    statsText.push({
                        text: `${document.querySelector(`label[for="${dep}"], label[for="${dep}_dep"]`)?.textContent || dep}: Median=${boxStats.median.toFixed(2)}, Q1=${boxStats.q1.toFixed(2)}, Q3=${boxStats.q3.toFixed(2)}, IQR=${boxStats.iqr.toFixed(2)}, Min=${boxStats.min.toFixed(2)}, Max=${boxStats.max.toFixed(2)}`,
                        color: color
                    });
                } else if (chartType === 'bar') {
                    const mean = jStat.mean(yValues);
                    const stdDev = jStat.stdev(yValues);
                    statsText.push({
                        text: `${document.querySelector(`label[for="${dep}"], label[for="${dep}_dep"]`)?.textContent || dep}: Mean=${mean.toFixed(2)}, StdDev=${stdDev.toFixed(2)}`,
                        color: color
                    });
                } else if (['scatter', 'line', 'area'].includes(chartType) && xValues.length > 1 && showFit) {
                    let xNum = xValues.map(x => independent === 'TIMESTAMP' ? x.getTime() : x);
                    let originalXMin = 0;
                    if (independent === 'TIMESTAMP') {
                        originalXMin = Math.min(...xNum);
                        xNum = xNum.map(x => (x - originalXMin) / (1000 * 60 * 60 * 24));
                    }
                    const fit = calculateFit(xNum, yValues, fitType);
                    if (fit.type !== 'none' && fit.yPred.length > 0) {
                        let xFit, yFit;
                        if (independent === 'TIMESTAMP') {
                            xFit = xNum.map(x => new Date(originalXMin + x * 1000 * 60 * 60 * 24));
                            yFit = fit.yPred;
                        } else {
                            const xMin = Math.min(...xNum);
                            const xMax = Math.max(...xNum);
                            xFit = Array.from({ length: 100 }, (_, i) => xMin + (xMax - xMin) * i / 99);
                            yFit = xFit.map(x => {
                                if (fit.type === 'linear') return fit.params.slope * x + fit.params.intercept;
                                if (fit.type === 'logarithmic') return fit.params.slope * Math.log(x) + fit.params.intercept;
                                if (fit.type === 'exponential') return fit.params.a * Math.exp(fit.params.b * x);
                                return NaN;
                            });
                        }
                        if (yFit.every(y => isFinite(y))) {
                            fitTraces.push({
                                x: xFit,
                                y: yFit,
                                mode: 'lines',
                                type: 'scatter',
                                name: `${document.querySelector(`label[for="${dep}"], label[for="${dep}_dep"]`)?.textContent || dep} (${fit.type} fit)`,
                                line: { color: color, width: 2, dash: 'dash' }
                            });
                        }
                    }
                    let eq = 'Fit not available';
                    if (fit.type === 'linear') {
                        eq = `y = ${fit.params.intercept.toFixed(2)} + ${fit.params.slope.toFixed(2)}x`;
                    } else if (fit.type === 'logarithmic') {
                        eq = `y = ${fit.params.intercept.toFixed(2)} + ${fit.params.slope.toFixed(2)}ln(x)`;
                    } else if (fit.type === 'exponential') {
                        eq = `y = ${fit.params.a.toFixed(2)}e^(${fit.params.b.toFixed(2)}x)`;
                    }
                    statsText.push({
                        text: `${document.querySelector(`label[for="${dep}"], label[for="${dep}_dep"]`)?.textContent || dep}: ${eq}, R²=${(fit.rSquared || NaN).toFixed(2)}, F=${(fit.fValue || NaN).toFixed(2)}, p=${(fit.pValue || NaN).toFixed(4)}`,
                        color: color
                    });
                }
            });
        }

        if (!traces.length) {
            console.warn('No valid traces to plot:', invalidTraces);
            resetGraph();
            return;
        }

        const allTraces = showFit ? [...traces, ...fitTraces] : traces;
        const statsContent = document.getElementById('stats-content');
        if (statsContent) {
            statsContent.innerHTML = statsText.length ? statsText.map(item => item.text).join('<br>') : 'No statistics available';
        }

        graphDiv.innerHTML = '';

        const annotations = showOnChart && statsText.length ? statsText.map((item, index) => ({
            xref: 'paper',
            yref: 'paper',
            x: 0.02,
            y: 0.98 - index * 0.05,
            xanchor: 'left',
            yanchor: 'top',
            text: item.text.replace(/p=0\.0000/, 'p<.0001').replace(/p=(\d+\.\d+)/, p => {
                const val = parseFloat(p.split('=')[1]);
                return val < 0.0001 ? 'p<.0001' : p;
            }),
            showarrow: false,
            font: {
                family: 'VT323, monospace',
                size: 14,
                color: item.color
            },
            bgcolor: 'rgba(26, 26, 26, 0.8)',
            bordercolor: '#00FFFF',
            borderwidth: 1,
            borderpad: 4
        })) : [];

        const layout = {
            title: {
                text: `SPRUCE Experiment: ${dependents.map(dep => document.querySelector(`label[for="${dep}"], label[for="${dep}_dep"]`)?.textContent || dep).join(', ')} vs ${independent === 'TIMESTAMP' ? 'Time' : document.querySelector(`label[for="${independent}"]`)?.textContent || independent}`,
                font: { color: '#FFFFFF', family: 'Exo 2', size: 16 }
            },
            xaxis: {
                title: independent === 'TIMESTAMP' ? 'Date' : `${document.querySelector(`label[for="${independent}"]`)?.textContent || independent} (${unitMap[independent] || ''})`,
                color: '#FFFFFF',
                gridcolor: '#444'
            },
            yaxis: {
                title: commonUnit ? `${dependents.map(dep => document.querySelector(`label[for="${dep}"], label[for="${dep}_dep"]`)?.textContent || dep).join(', ')} (${commonUnit})` : 'Multiple Units',
                color: '#FFFFFF',
                gridcolor: '#444'
            },
            paper_bgcolor: '#1A1A1A',
            plot_bgcolor: '#1A1A1A',
            font: { color: '#FFFFFF' },
            showlegend: legendVisible,
            width: calculateGraphWidth(),
            height: calculateGraphHeight(),
            margin: { t: 50, b: 50, l: 100, r: 50 },
            annotations: annotations
        };

        Plotly.newPlot(graphDiv, allTraces, layout, { responsive: true });
        graphInitialized = true;
        console.log('Graph plotted successfully with', annotations.length, 'annotations');
    } catch (error) {
        console.error('Error in updateGraph:', error);
        resetGraph();
        graphDiv.innerHTML = '<div class="warning-message">Error rendering graph. Check console for details.</div>';
    }
}

// Event listener setup
function setupEventListeners() {
    console.log('Setting up event listeners');

    const sidebarTab = document.getElementById('sidebar-tab');
    if (sidebarTab) {
        sidebarTab.addEventListener('click', toggleSidebar);
    }

    const mobileSidebarButton = document.getElementById('mobile-sidebar-button');
    if (mobileSidebarButton) {
        mobileSidebarButton.addEventListener('click', toggleSidebar);
    }

    const controlPanelButton = document.getElementById('control-panel-button');
    if (controlPanelButton) {
        controlPanelButton.addEventListener('click', toggleControlPanel);
    }

    const closeControlPanel = document.getElementById('close-control-panel');
    if (closeControlPanel) {
        closeControlPanel.addEventListener('click', () => {
            const popup = document.getElementById('control-panel-popup');
            const button = document.getElementById('control-panel-button');
            if (popup && button) {
                popup.style.display = 'none';
                button.textContent = 'Show Control Panel';
                console.log('Control panel popup closed');
            }
        });
    }

    const closePlotSelection = document.getElementById('close-plot-selection');
    if (closePlotSelection) {
        closePlotSelection.addEventListener('click', () => {
            const popup = document.getElementById('plot-selection-popup');
            if (popup) {
                popup.style.display = 'none';
                console.log('Plot selection popup closed');
            }
        });
    }

    ['independent', 'dependent', 'time-range', 'chart-type', 'stats', 'metagenomics'].forEach(type => {
        const toggle = document.getElementById(`${type}-toggle`);
        const menu = document.getElementById(`${type}-menu`);
        if (toggle && menu) {
            toggle.addEventListener('click', () => toggleDropdown(`${type}-menu`));
        }
    });

    const independentMenu = document.getElementById('independent-menu');
    if (independentMenu) {
        independentMenu.addEventListener('change', (e) => {
            if (e.target.type === 'checkbox') {
                enforceSingleSelection('independent-menu', e.target.id);
                updateGraph();
            }
        });
    }

    const dependentMenu = document.getElementById('dependent-menu');
    if (dependentMenu) {
        dependentMenu.addEventListener('change', updateGraph);
    }

    const chartTypeMenu = document.getElementById('chart-type-menu');
    if (chartTypeMenu) {
        chartTypeMenu.addEventListener('change', () => {
            updateStatsOptions();
            updateGraph();
        });
    }

    const statsMenu = document.getElementById('stats-menu');
    if (statsMenu) {
        statsMenu.addEventListener('change', updateGraph);
    }

    const metagenomicsLinks = document.querySelectorAll('.metagenomics-link');
    metagenomicsLinks.forEach(link => {
        link.addEventListener('click', (e) => {
            e.preventDefault();
            const popup = document.getElementById('metagenomics-popup');
            const iframe = document.getElementById('metagenomics-iframe');
            if (!popup || !iframe) return;
            if (link.classList.contains('kraken-stacked-bar')) {
                showStackedBarChart(e);
            } else {
                const sampleId = link.href.match(/SRR\d+/)?.[0];
                const isMultiQC = link.href.includes('multiqc_report.html');
                const plotNumber = sampleId ? sampleToPlotMap[sampleId]?.plot : null;
                if (!sampleId || isMultiQC || !selectedPlots.length || (plotNumber && selectedPlots.includes(plotNumber))) {
                    popup.style.display = 'block';
                    iframe.src = link.href;
                    iframe.onerror = () => {
                        iframe.src = '';
                        const message = isMultiQC ? 'Failed to load MultiQC report. Please check the URL or GitHub Pages configuration.' : 'Failed to load Krona report. Please check the URL or try again later.';
                        iframe.insertAdjacentHTML('afterend', `<div class="warning-message">${message}</div>`);
                        console.error('Iframe load failed for URL:', link.href);
                    };
                    console.log('Metagenomics popup opened with URL:', link.href);
                }
            }
        });
    });

    const closeMetagenomics = document.getElementById('close-metagenomics');
    if (closeMetagenomics) {
        closeMetagenomics.addEventListener('click', () => {
            const popup = document.getElementById('metagenomics-popup');
            const iframe = document.getElementById('metagenomics-iframe');
            if (popup && iframe) {
                popup.style.display = 'none';
                iframe.src = '';
                const warning = iframe.nextElementSibling;
                if (warning && warning.classList.contains('warning-message')) {
                    warning.remove();
                }
                console.log('Metagenomics popup closed');
            }
        });
    }

    flatpickr('#start-date', {
        dateFormat: 'Y-m-d',
        onChange: (selectedDates) => {
            startDate = selectedDates[0];
            const timeRangeToggle = document.getElementById('time-range-toggle');
            if (timeRangeToggle) {
                timeRangeToggle.textContent = `${startDate.toISOString().split('T')[0]} - ${endDate.toISOString().split('T')[0]}`;
            }
            updateGraph();
        }
    });

    flatpickr('#end-date', {
        dateFormat: 'Y-m-d',
        onChange: (selectedDates) => {
            endDate = selectedDates[0];
            const timeRangeToggle = document.getElementById('time-range-toggle');
            if (timeRangeToggle) {
                timeRangeToggle.textContent = `${startDate.toISOString().split('T')[0]} - ${endDate.toISOString().split('T')[0]}`;
            }
            updateGraph();
        }
    });

    const timestampCheckbox = document.getElementById('TIMESTAMP');
    if (timestampCheckbox) {
        timestampCheckbox.checked = true;
        enforceSingleSelection('independent-menu', 'TIMESTAMP');
    }
}

// DOMContentLoaded handler
document.addEventListener('DOMContentLoaded', () => {
    console.log('DOMContentLoaded fired');
    try {
        if (typeof Plotly === 'undefined' || typeof jStat === 'undefined') {
            console.error('Plotly or jStat not loaded');
            const graphDiv = document.getElementById('graph');
            if (graphDiv) {
                graphDiv.innerHTML = '<div class="warning-message">Required libraries not loaded.</div>';
            }
            return;
        }
        setupEventListeners();
        loadData();
        updateMetagenomics();
    } catch (error) {
        console.error('Error in DOMContentLoaded:', error);
        const graphDiv = document.getElementById('graph');
        if (graphDiv) {
            graphDiv.innerHTML = '<div class="warning-message">Error in script setup. Check console for details.</div>';
        }
    }
});

</script>
</body>
</html>
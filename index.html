<script>
    const baseUrl = 'https://raw.githubusercontent.com/aime2solve/SPRUCE/main/';
    let allData = [];
    let filteredData = [];
    const plots = Array.from({ length: 21 }, (_, i) => i + 1);
    const knownFiles = [
        'WEW PLOT_04_Complete_Environ_20160826.csv',
        'WEW PLOT_06_Complete_Environ_20160826.csv',
        'WEW PLOT_08_Complete_Environ_20160826.csv',
        'WEW PLOT_10_Complete_Environ_20160826.csv',
        'WEW PLOT_21_Complete_Environ_20160826.csv'
    ];
    let startDate = null;
    let endDate = null;

    Plotly.newPlot('graph', [], {
        title: 'Loading SPRUCE Data...',
        plot_bgcolor: '#1A1A1A',
        paper_bgcolor: '#1A1A1A',
        font: { color: '#FFFFFF' },
        xaxis: { gridcolor: '#333333' },
        yaxis: { gridcolor: '#333333' }
    }, { responsive: true });

    function populatePlotDropdown() {
        const plotMenu = document.getElementById('plot-menu');
        plotMenu.innerHTML = '';
        plots.forEach(plot => {
            const div = document.createElement('div');
            div.className = 'dropdown-item';
            const input = document.createElement('input');
            input.type = 'checkbox';
            input.id = `plot-${plot}`;
            input.value = plot;
            input.checked = true;
            input.addEventListener('change', debounceUpdateGraph);
            const label = document.createElement('label');
            label.htmlFor = `plot-${plot}`;
            label.textContent = `Plot ${plot}`;
            div.appendChild(input);
            div.appendChild(label);
            plotMenu.appendChild(div);
        });
    }

    async function fetchFileData(filename) {
        const url = `${baseUrl}${filename}`;
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
            const csvText = await response.text();
            const result = Papa.parse(csvText, { header: true, dynamicTyping: true });
            const plot = parseInt(filename.match(/PLOT_(\d+)/)[1]);
            console.log(`Loaded ${filename}: ${result.data.length} rows`);
            return result.data.map(row => ({ ...row, Plot: plot, TIMESTAMP: row.TIMESTAMP }));
        } catch (error) {
            console.error(`Error fetching ${filename}:`, error);
            return [];
        }
    }

    async function loadData() {
        const promises = knownFiles.map(file => fetchFileData(file));
        const results = await Promise.all(promises);
        allData = results.flat();
        console.log(`Total rows loaded: ${allData.length}`);
        filteredData = allData; // Initial filter
        updateGraph();
    }

    function toggleDropdown(id) {
        const menu = document.getElementById(id);
        menu.classList.toggle('open');
    }

    function toggleSidebar() {
        const sidebar = document.getElementById('sidebar');
        const graphContainer = document.getElementById('graph-container');
        const tab = document.getElementById('sidebar-tab');
        sidebar.classList.toggle('collapsed');
        graphContainer.classList.toggle('full-width');
        tab.textContent = sidebar.classList.contains('collapsed') ? '<' : '>';
        Plotly.Plots.resize('graph');
    }

    function debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }

    const debounceUpdateGraph = debounce(updateGraph, 300);

    function enforceSingleSelection(groupId, changedId) {
        const checkboxes = document.querySelectorAll(`#${groupId} input[type="checkbox"]`);
        checkboxes.forEach(checkbox => {
            if (checkbox.id !== changedId && checkbox.checked) {
                checkbox.checked = false;
            }
        });
    }

    function updateGraph() {
        const selectedPlots = Array.from(document.querySelectorAll('#plot-menu input:checked')).map(input => parseInt(input.value));
        const independent = Array.from(document.querySelectorAll('#independent-menu input:checked'))[0]?.value || 'Temp_target';
        const dependent = Array.from(document.querySelectorAll('#dependent-menu input:checked'))[0]?.value || 'TS_0__A1';
        const conditions = Array.from(document.querySelectorAll('#condition-menu input:checked')).map(input => input.value);

        // Pre-filter data once
        let workingData = allData.filter(row => selectedPlots.includes(row.Plot));
        if (startDate || endDate) {
            workingData = workingData.filter(row => {
                const rowDate = new Date(row.TIMESTAMP);
                return (!startDate || rowDate >= startDate) && (!endDate || rowDate <= endDate);
            });
        }
        conditions.forEach(cond => {
            workingData = workingData.filter(row => row[cond] !== undefined && row[cond] !== null && row[cond] !== 0);
        });

        // Limit total points to 5000, distributing across plots
        const maxPoints = 5000;
        const pointsPerPlot = Math.floor(maxPoints / selectedPlots.length) || 1;
        const traces = [];
        const noDataPlots = [];
        selectedPlots.forEach(plot => {
            const plotData = workingData.filter(row => row.Plot === plot);
            if (plotData.length === 0) {
                noDataPlots.push(`No data for Plot ${plot}`);
                return;
            }
            const limitedData = plotData.slice(0, pointsPerPlot);
            const x = limitedData.map(row => row[independent]).filter(v => v !== undefined && v !== null);
            const y = limitedData.map(row => row[dependent]).filter(v => v !== undefined && v !== null);
            if (x.length > 0 && y.length > 0) {
                traces.push({
                    x: x,
                    y: y,
                    mode: 'markers',
                    name: `Plot ${plot}`,
                    marker: { size: 12, color: `#${Math.floor(Math.random()*16777215).toString(16)}` }
                });
            }
        });

        const allY = workingData.map(row => row[dependent]).filter(v => v !== undefined && v !== null);
        const statsText = allY.length > 0 ? 
            `Mean: ${(allY.reduce((sum, val) => sum + val, 0) / allY.length).toFixed(2)}, ` +
            `Min: ${Math.min(...allY).toFixed(2)}, Max: ${Math.max(...allY).toFixed(2)}, Points: ${allY.length}` :
            'No data points';
        document.getElementById('stats-content').innerHTML = statsText;

        const layout = {
            title: `${dependent.replace(/_/g, ' ')} vs ${independent.replace(/_/g, ' ')}` + 
                   (noDataPlots.length ? '<br>' + noDataPlots.join('<br>') : ''),
            plot_bgcolor: '#1A1A1A',
            paper_bgcolor: '#1A1A1A',
            font: { color: '#FFFFFF' },
            xaxis: { title: document.querySelector(`label[for="${independent}"]`)?.textContent || independent, gridcolor: '#333333' },
            yaxis: { title: document.querySelector(`label[for="${dependent}"]`)?.textContent || dependent, gridcolor: '#333333' },
            showlegend: true
        };

        if (traces.length === 0) {
            layout.title = 'No Data to Plot' + (noDataPlots.length ? '<br>' + noDataPlots.join('<br>') : '');
        }
        Plotly.newPlot('graph', traces, layout, { responsive: true }).catch(err => console.error('Plotly error:', err));
    }

    document.getElementById('sidebar-tab').addEventListener('click', toggleSidebar);
    document.getElementById('plot-toggle').addEventListener('click', () => toggleDropdown('plot-menu'));
    document.getElementById('independent-toggle').addEventListener('click', () => toggleDropdown('independent-menu'));
    document.getElementById('dependent-toggle').addEventListener('click', () => toggleDropdown('dependent-menu'));
    document.getElementById('condition-toggle').addEventListener('click', () => toggleDropdown('condition-menu'));
    document.getElementById('time-range-toggle').addEventListener('click', () => toggleDropdown('time-range-menu'));
    document.getElementById('stats-toggle').addEventListener('click', () => {
        const statsPanel = document.getElementById('stats-panel');
        statsPanel.classList.toggle('open');
        document.getElementById('stats-toggle').textContent = statsPanel.classList.contains('open') ? 'Hide Stats' : 'Show Stats';
    });

    document.querySelectorAll('#independent-menu input').forEach(input => {
        input.addEventListener('change', () => {
            enforceSingleSelection('independent-menu', input.id);
            document.getElementById('independent-toggle').textContent = document.querySelector(`label[for="${input.id}"]`).textContent;
            debounceUpdateGraph();
        });
        if (input.id === 'Temp_target') input.checked = true; // Default
    });

    document.querySelectorAll('#dependent-menu input').forEach(input => {
        input.addEventListener('change', () => {
            enforceSingleSelection('dependent-menu', input.id);
            document.getElementById('dependent-toggle').textContent = document.querySelector(`label[for="${input.id}"]`).textContent;
            debounceUpdateGraph();
        });
        if (input.id === 'TS_0__A1') input.checked = true; // Default
    });

    document.querySelectorAll('#condition-menu input').forEach(input => {
        input.addEventListener('change', debounceUpdateGraph);
    });

    flatpickr('#start-date', {
        dateFormat: 'Y-m-d',
        onChange: (selectedDates) => {
            startDate = selectedDates[0];
            document.getElementById('time-range-toggle').textContent = 
                `${startDate ? startDate.toISOString().split('T')[0] : 'Start'} - ${endDate ? endDate.toISOString().split('T')[0] : 'End'}`;
            debounceUpdateGraph();
        }
    });

    flatpickr('#end-date', {
        dateFormat: 'Y-m-d',
        onChange: (selectedDates) => {
            endDate = selectedDates[0];
            document.getElementById('time-range-toggle').textContent = 
                `${startDate ? startDate.toISOString().split('T')[0] : 'Start'} - ${endDate ? endDate.toISOString().split('T')[0] : 'End'}`;
            debounceUpdateGraph();
        }
    });

    populatePlotDropdown();
    loadData();
</script>